<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.5" xml:lang="en-US">
  <compounddef id="group__DictUtils" kind="group">
    <compoundname>DictUtils</compoundname>
    <title>How to access the value contained in a Token contained in</title>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__DictUtils_1ga0445ccdaa7ff4b5a81644646bb83d631" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FT</type>
          </param>
        </templateparamlist>
        <type>FT</type>
        <definition>FT getValue</definition>
        <argsstring>(const DictionaryDatum &amp;d, Name const n)</argsstring>
        <name>getValue</name>
        <param>
          <type>const <ref refid="dictdatum_8h_1a4a4d8eba002ed1473f9f196598b268bc" kindref="member">DictionaryDatum</ref> &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="className" kindref="compound">Name</ref> const</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>Get the value of an existing dictionary entry. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>UnknownName</parametername>
</parameternamelist>
<parameterdescription>
<para>An entry of the given name is not known in the dictionary. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" line="60" column="1" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" bodystart="60" bodyend="70"/>
        <referencedby refid="classSLIArrayModule_1_1Array2IntVectorFunction_1a386ae8e5715f790973989e63b800fe14" compoundref="sliarray_8cc" startline="2885" endline="2904">SLIArrayModule::Array2IntVectorFunction::execute</referencedby>
        <referencedby refid="classSLIArrayModule_1_1Array2DoubleVectorFunction_1a925484705807b74386c1dd4fc96a2122" compoundref="sliarray_8cc" startline="2907" endline="2926">SLIArrayModule::Array2DoubleVectorFunction::execute</referencedby>
      </memberdef>
      <memberdef kind="function" id="group__DictUtils_1ga46187a005b28a029032ae44cdfacd12f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double get_double_in_range</definition>
        <argsstring>(const DictionaryDatum &amp;d, Name const n, double min, double max, int mode=2)</argsstring>
        <name>get_double_in_range</name>
        <param>
          <type>const <ref refid="dictdatum_8h_1a4a4d8eba002ed1473f9f196598b268bc" kindref="member">DictionaryDatum</ref> &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="className" kindref="compound">Name</ref> const</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double</type>
          <declname>min</declname>
        </param>
        <param>
          <type>double</type>
          <declname>max</declname>
        </param>
        <param>
          <type>int</type>
          <declname>mode</declname>
          <defval>2</defval>
        </param>
        <briefdescription>
<para>Get the value of an existing dictionary entry and check that it is in a specified range. </para>
        </briefdescription>
        <detaileddescription>
<para>The range is specified by two parameters min and max which have the same type as the template argument. The last parameter mode defines the type of the range: </para>
<sect2 id="group__DictUtils_1autotoc_md12">
<title>Mode    Relation</title>
<para>0 min &lt; x &lt; max 1 min &lt;= x &lt; max 2 min &lt;= x &lt;= max</para>
<para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>UnknownName</parametername>
</parameternamelist>
<parameterdescription>
<para>An entry of the given name is not known in the dictionary. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername><ref refid="classRangeCheck" kindref="compound">RangeCheck</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>if a value is outside the range </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" line="88" column="1" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" bodystart="88" bodyend="134"/>
        <references refid="classToken_1a309bb2d7f89471b3aa7ca63cfbde65e4" compoundref="token_8h" startline="360" endline="364">Token::datum</references>
        <references refid="classGenericDatum_1a2204e0bfb80429863ebbd37005235c1e" compoundref="genericdatum_8h" startline="74" endline="77">GenericDatum&lt; D, slt &gt;::get</references>
      </memberdef>
      <memberdef kind="function" id="group__DictUtils_1ga2884b30013642c7ea26a1a6e64707f8c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>long</type>
        <definition>long get_long_in_range</definition>
        <argsstring>(const DictionaryDatum &amp;d, Name const n, long min, long max, int mode=2)</argsstring>
        <name>get_long_in_range</name>
        <param>
          <type>const <ref refid="dictdatum_8h_1a4a4d8eba002ed1473f9f196598b268bc" kindref="member">DictionaryDatum</ref> &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="className" kindref="compound">Name</ref> const</type>
          <declname>n</declname>
        </param>
        <param>
          <type>long</type>
          <declname>min</declname>
        </param>
        <param>
          <type>long</type>
          <declname>max</declname>
        </param>
        <param>
          <type>int</type>
          <declname>mode</declname>
          <defval>2</defval>
        </param>
        <briefdescription>
<para>Get the value of an existing dictionary entry and check that it is in a specified range. </para>
        </briefdescription>
        <detaileddescription>
<para>The range is specified by two parameters min and max which have the same type as the template argument. The last parameter mode defines the type of the range: </para>
<sect2 id="group__DictUtils_1autotoc_md13">
<title>Mode    Relation</title>
<para>0 min &lt; x &lt; max 1 min &lt;= x &lt; max 2 min &lt;= x &lt;= max</para>
<para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>UnknownName</parametername>
</parameternamelist>
<parameterdescription>
<para>An entry of the given name is not known in the dictionary. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername><ref refid="classRangeCheck" kindref="compound">RangeCheck</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>if a value is outside the range </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" line="152" column="1" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" bodystart="152" bodyend="198"/>
        <references refid="classToken_1a309bb2d7f89471b3aa7ca63cfbde65e4" compoundref="token_8h" startline="360" endline="364">Token::datum</references>
        <references refid="classGenericDatum_1a2204e0bfb80429863ebbd37005235c1e" compoundref="genericdatum_8h" startline="74" endline="77">GenericDatum&lt; D, slt &gt;::get</references>
      </memberdef>
      <memberdef kind="function" id="group__DictUtils_1gadf5b108954ce819f3201465dfc2daa49" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FT</type>
          </param>
          <param>
            <type>class D</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void def2</definition>
        <argsstring>(DictionaryDatum &amp;d, Name const n, FT const &amp;value)</argsstring>
        <name>def2</name>
        <param>
          <type><ref refid="dictdatum_8h_1a4a4d8eba002ed1473f9f196598b268bc" kindref="member">DictionaryDatum</ref> &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="className" kindref="compound">Name</ref> const</type>
          <declname>n</declname>
        </param>
        <param>
          <type>FT const &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Define a new dictionary entry from a fundamental type. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername><ref refid="classTypeMismatch" kindref="compound">TypeMismatch</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>Fundamental type and requested SLI type are incompatible. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" line="208" column="1" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" bodystart="208" bodyend="212"/>
      </memberdef>
      <memberdef kind="function" id="group__DictUtils_1ga6fcda26ba5ae984d7e6aa0e5bbfe4b72" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FT</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void def</definition>
        <argsstring>(DictionaryDatum &amp;d, Name const n, FT const &amp;value)</argsstring>
        <name>def</name>
        <param>
          <type><ref refid="dictdatum_8h_1a4a4d8eba002ed1473f9f196598b268bc" kindref="member">DictionaryDatum</ref> &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="className" kindref="compound">Name</ref> const</type>
          <declname>n</declname>
        </param>
        <param>
          <type>FT const &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Define a new dictionary entry from a fundamental type. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername><ref refid="classTypeMismatch" kindref="compound">TypeMismatch</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>Creating a <ref refid="classToken" kindref="compound">Token</ref> from the fundamental type failed, probably due to a missing template specialization. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" line="221" column="1" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" bodystart="221" bodyend="225"/>
        <referencedby refid="classnest_1_1Layer_1ac1b9a1c8651f3eefae09c200e00974af" compoundref="layer__impl_8h" startline="300" endline="351">nest::Layer&lt; D &gt;::dump_connections</referencedby>
      </memberdef>
      <memberdef kind="function" id="group__DictUtils_1ga44cdfb140502a5d84d5a798c259f0073" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FT</type>
          </param>
          <param>
            <type>typename VT</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool updateValue</definition>
        <argsstring>(DictionaryDatum const &amp;d, Name const n, VT &amp;value)</argsstring>
        <name>updateValue</name>
        <param>
          <type><ref refid="dictdatum_8h_1a4a4d8eba002ed1473f9f196598b268bc" kindref="member">DictionaryDatum</ref> const &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="className" kindref="compound">Name</ref> const</type>
          <declname>n</declname>
        </param>
        <param>
          <type>VT &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Update a variable from a dictionary entry if it exists, skip call if it doesn&apos;t. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>If the dictionary entry is an integer, use updateValue&lt; long &gt;.</para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>see</parametername>
</parameternamelist>
<parameterdescription>
<para>getValue(DictionaryDatum, Name) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" line="235" column="1" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" bodystart="235" bodyend="255"/>
        <references refid="classToken_1a397db8062278fec3e786aa62f9d9baf8" compoundref="token_8h" startline="348" endline="351">Token::empty</references>
        <references refid="className_1a8ee5a44599eb7a686ee64c343e0c8e18" compoundref="name_8h" startline="118" endline="122">Name::lookup</references>
        <referencedby refid="structnest_1_1correlation__detector_1_1State___1a573664942485b5bb088cb79c2afebbc4" compoundref="correlation__detector_8cpp" startline="163" endline="181">nest::correlation_detector::State_::set</referencedby>
        <referencedby refid="structnest_1_1glif__psc_1_1Parameters___1a43b976fb6f21d3ac6b9f519d6bf0d304" compoundref="glif__psc_8cpp" startline="145" endline="296">nest::glif_psc::Parameters_::set</referencedby>
        <referencedby refid="structnest_1_1gif__psc__exp__multisynapse_1_1Parameters___1a910f8608b89c61ed07a96ea1497b24a5" compoundref="gif__psc__exp__multisynapse_8cpp" startline="134" endline="230">nest::gif_psc_exp_multisynapse::Parameters_::set</referencedby>
        <referencedby refid="structnest_1_1iaf__psc__alpha__multisynapse_1_1Parameters___1a2d95fe0016185129aae798b145a6f487" compoundref="iaf__psc__alpha__multisynapse_8cpp" startline="136" endline="210">nest::iaf_psc_alpha_multisynapse::Parameters_::set</referencedby>
        <referencedby refid="structnest_1_1iaf__psc__exp__multisynapse_1_1Parameters___1a8be43024821bd9a51067eabfafc664c0" compoundref="iaf__psc__exp__multisynapse_8cpp" startline="131" endline="198">nest::iaf_psc_exp_multisynapse::Parameters_::set</referencedby>
        <referencedby refid="structnest_1_1pulsepacket__generator_1_1Parameters___1adc6411fadadd26f98280879ddc57a662" compoundref="pulsepacket__generator_8cpp" startline="75" endline="97">nest::pulsepacket_generator::Parameters_::set</referencedby>
      </memberdef>
      <memberdef kind="function" id="group__DictUtils_1ga5faad6767e320399223367fa2c04a8a7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FT</type>
          </param>
          <param>
            <type>typename VT</type>
          </param>
          <param>
            <type>class C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void updateValue2</definition>
        <argsstring>(DictionaryDatum const &amp;d, Name const n, C &amp;obj, void(C::*setfunc)(VT))</argsstring>
        <name>updateValue2</name>
        <param>
          <type><ref refid="dictdatum_8h_1a4a4d8eba002ed1473f9f196598b268bc" kindref="member">DictionaryDatum</ref> const &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="className" kindref="compound">Name</ref> const</type>
          <declname>n</declname>
        </param>
        <param>
          <type>C &amp;</type>
          <declname>obj</declname>
        </param>
        <param>
          <type>void(C::*)(VT)</type>
          <declname>setfunc</declname>
        </param>
        <briefdescription>
<para>Call a member function of an object, passing the value of an dictionary entry if it exists, skip call if it doesn&apos;t. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>see</parametername>
</parameternamelist>
<parameterdescription>
<para>getValue(DictionaryDatum, Name) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" line="264" column="1" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" bodystart="264" bodyend="271"/>
      </memberdef>
      <memberdef kind="function" id="group__DictUtils_1gaeb39309693e8740af1323d58dae4277f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void initialize_property_array</definition>
        <argsstring>(DictionaryDatum &amp;d, Name propname)</argsstring>
        <name>initialize_property_array</name>
        <param>
          <type><ref refid="dictdatum_8h_1a4a4d8eba002ed1473f9f196598b268bc" kindref="member">DictionaryDatum</ref> &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="className" kindref="compound">Name</ref></type>
          <declname>propname</declname>
        </param>
        <briefdescription>
<para>Create a property of type ArrayDatum in the dictionary, if it does not already exist. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" line="277" column="6" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.cc" bodystart="26" bodyend="34" declfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" declline="277" declcolumn="6"/>
        <references refid="classToken_1a397db8062278fec3e786aa62f9d9baf8" compoundref="token_8h" startline="348" endline="351">Token::empty</references>
        <references refid="className_1a8ee5a44599eb7a686ee64c343e0c8e18" compoundref="name_8h" startline="118" endline="122">Name::lookup</references>
        <referencedby refid="structnest_1_1RecordingBackendASCII_1_1DeviceData_1a64219cbc9de401ebd5677b8a3cef4afe" compoundref="recording__backend__ascii_8cpp" startline="326" endline="335">nest::RecordingBackendASCII::DeviceData::get_status</referencedby>
      </memberdef>
      <memberdef kind="function" id="group__DictUtils_1gaca5cefae6151612dea3da39adc295c78" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void initialize_property_doublevector</definition>
        <argsstring>(DictionaryDatum &amp;d, Name propname)</argsstring>
        <name>initialize_property_doublevector</name>
        <param>
          <type><ref refid="dictdatum_8h_1a4a4d8eba002ed1473f9f196598b268bc" kindref="member">DictionaryDatum</ref> &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="className" kindref="compound">Name</ref></type>
          <declname>propname</declname>
        </param>
        <briefdescription>
<para>Create a property of type DoubleVectorDatum in the dictionary, if it does not already exist. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" line="284" column="6" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.cc" bodystart="37" bodyend="45" declfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" declline="284" declcolumn="6"/>
        <references refid="classToken_1a397db8062278fec3e786aa62f9d9baf8" compoundref="token_8h" startline="348" endline="351">Token::empty</references>
        <references refid="className_1a8ee5a44599eb7a686ee64c343e0c8e18" compoundref="name_8h" startline="118" endline="122">Name::lookup</references>
        <referencedby refid="structnest_1_1RecordingBackendMemory_1_1DeviceData_1a59027dbfb942b3b10b6c09265bbfb14c" compoundref="recording__backend__memory_8cpp" startline="218" endline="261">nest::RecordingBackendMemory::DeviceData::get_status</referencedby>
      </memberdef>
      <memberdef kind="function" id="group__DictUtils_1gadc6126c32cd382bccbcfbc788c6f650f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void initialize_property_intvector</definition>
        <argsstring>(DictionaryDatum &amp;d, Name propname)</argsstring>
        <name>initialize_property_intvector</name>
        <param>
          <type><ref refid="dictdatum_8h_1a4a4d8eba002ed1473f9f196598b268bc" kindref="member">DictionaryDatum</ref> &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="className" kindref="compound">Name</ref></type>
          <declname>propname</declname>
        </param>
        <briefdescription>
<para>Create a property of type IntVectorDatum in the dictionary, if it does not already exist. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" line="291" column="6" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.cc" bodystart="48" bodyend="56" declfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" declline="291" declcolumn="6"/>
        <references refid="classToken_1a397db8062278fec3e786aa62f9d9baf8" compoundref="token_8h" startline="348" endline="351">Token::empty</references>
        <references refid="className_1a8ee5a44599eb7a686ee64c343e0c8e18" compoundref="name_8h" startline="118" endline="122">Name::lookup</references>
        <referencedby refid="structnest_1_1RecordingBackendMemory_1_1DeviceData_1a59027dbfb942b3b10b6c09265bbfb14c" compoundref="recording__backend__memory_8cpp" startline="218" endline="261">nest::RecordingBackendMemory::DeviceData::get_status</referencedby>
      </memberdef>
      <memberdef kind="function" id="group__DictUtils_1gad4634f6e310641d68ed5efe2a2181e96" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename PropT</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void append_property</definition>
        <argsstring>(DictionaryDatum &amp;d, Name propname, const PropT &amp;prop)</argsstring>
        <name>append_property</name>
        <param>
          <type><ref refid="dictdatum_8h_1a4a4d8eba002ed1473f9f196598b268bc" kindref="member">DictionaryDatum</ref> &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="className" kindref="compound">Name</ref></type>
          <declname>propname</declname>
        </param>
        <param>
          <type>const PropT &amp;</type>
          <declname>prop</declname>
        </param>
        <briefdescription>
<para>Append a value to a property ArrayDatum in the dictionary. </para>
        </briefdescription>
        <detaileddescription>
<para>This is the version for scalar values </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" line="300" column="1" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" bodystart="300" bodyend="310"/>
        <references refid="classToken_1a309bb2d7f89471b3aa7ca63cfbde65e4" compoundref="token_8h" startline="360" endline="364">Token::datum</references>
        <references refid="classToken_1a397db8062278fec3e786aa62f9d9baf8" compoundref="token_8h" startline="348" endline="351">Token::empty</references>
        <references refid="className_1a8ee5a44599eb7a686ee64c343e0c8e18" compoundref="name_8h" startline="118" endline="122">Name::lookup</references>
        <referencedby refid="structnest_1_1RecordingBackendASCII_1_1DeviceData_1a64219cbc9de401ebd5677b8a3cef4afe" compoundref="recording__backend__ascii_8cpp" startline="326" endline="335">nest::RecordingBackendASCII::DeviceData::get_status</referencedby>
        <referencedby refid="structnest_1_1RecordingBackendMemory_1_1DeviceData_1a59027dbfb942b3b10b6c09265bbfb14c" compoundref="recording__backend__memory_8cpp" startline="218" endline="261">nest::RecordingBackendMemory::DeviceData::get_status</referencedby>
      </memberdef>
      <memberdef kind="function" id="group__DictUtils_1ga3597227196f33fec1c8bb2f104ab2c57" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>void</type>
        <definition>void append_property&lt; std::vector&lt; double &gt; &gt;</definition>
        <argsstring>(DictionaryDatum &amp;d, Name propname, const std::vector&lt; double &gt; &amp;prop)</argsstring>
        <name>append_property&lt; std::vector&lt; double &gt; &gt;</name>
        <param>
          <type><ref refid="dictdatum_8h_1a4a4d8eba002ed1473f9f196598b268bc" kindref="member">DictionaryDatum</ref> &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="className" kindref="compound">Name</ref></type>
          <declname>propname</declname>
        </param>
        <param>
          <type>const std::vector&lt; double &gt; &amp;</type>
          <declname>prop</declname>
        </param>
        <briefdescription>
<para>Append a value to a property DoubleVectorDatum in the dictionary. </para>
        </briefdescription>
        <detaileddescription>
<para>This is a specialization for appending vector&lt;double&gt;s to vector&lt;double&gt;s </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" line="317" column="8" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" bodystart="318" bodyend="327"/>
        <references refid="classToken_1a309bb2d7f89471b3aa7ca63cfbde65e4" compoundref="token_8h" startline="360" endline="364">Token::datum</references>
        <references refid="classToken_1a397db8062278fec3e786aa62f9d9baf8" compoundref="token_8h" startline="348" endline="351">Token::empty</references>
        <references refid="className_1a8ee5a44599eb7a686ee64c343e0c8e18" compoundref="name_8h" startline="118" endline="122">Name::lookup</references>
      </memberdef>
      <memberdef kind="function" id="group__DictUtils_1gabf555c4346a3aeeae1e0b303beea2031" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>void</type>
        <definition>void append_property&lt; std::vector&lt; long &gt; &gt;</definition>
        <argsstring>(DictionaryDatum &amp;d, Name propname, const std::vector&lt; long &gt; &amp;prop)</argsstring>
        <name>append_property&lt; std::vector&lt; long &gt; &gt;</name>
        <param>
          <type><ref refid="dictdatum_8h_1a4a4d8eba002ed1473f9f196598b268bc" kindref="member">DictionaryDatum</ref> &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="className" kindref="compound">Name</ref></type>
          <declname>propname</declname>
        </param>
        <param>
          <type>const std::vector&lt; long &gt; &amp;</type>
          <declname>prop</declname>
        </param>
        <briefdescription>
<para>Append a value to a property IntVectorDatum in the dictionary. </para>
        </briefdescription>
        <detaileddescription>
<para>This is a specialization for appending vector&lt;long&gt;s to vector&lt;long&gt;s </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" line="335" column="8" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" bodystart="336" bodyend="345"/>
        <references refid="classToken_1a309bb2d7f89471b3aa7ca63cfbde65e4" compoundref="token_8h" startline="360" endline="364">Token::datum</references>
        <references refid="classToken_1a397db8062278fec3e786aa62f9d9baf8" compoundref="token_8h" startline="348" endline="351">Token::empty</references>
        <references refid="className_1a8ee5a44599eb7a686ee64c343e0c8e18" compoundref="name_8h" startline="118" endline="122">Name::lookup</references>
      </memberdef>
      <memberdef kind="function" id="group__DictUtils_1gab7a520a9b1a45325ab4fcc550dee5e9b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void provide_property</definition>
        <argsstring>(DictionaryDatum &amp;, Name, const std::vector&lt; double &gt; &amp;)</argsstring>
        <name>provide_property</name>
        <param>
          <type><ref refid="dictdatum_8h_1a4a4d8eba002ed1473f9f196598b268bc" kindref="member">DictionaryDatum</ref> &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="className" kindref="compound">Name</ref></type>
          <declname>propname</declname>
        </param>
        <param>
          <type>const std::vector&lt; double &gt; &amp;</type>
          <declname>prop</declname>
        </param>
        <briefdescription>
<para>Provide a value to a property DoubleVectorDatum in the dictionary. </para>
        </briefdescription>
        <detaileddescription>
<para>In contrast to append_property, this function adds the value only once to the property. On all subsequent events, it ensures that the value passed in is identical to the value present. This is needed by recording_decive. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" line="355" column="6" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.cc" bodystart="59" bodyend="73" declfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" declline="355" declcolumn="6"/>
        <references refid="classToken_1a309bb2d7f89471b3aa7ca63cfbde65e4" compoundref="token_8h" startline="360" endline="364">Token::datum</references>
      </memberdef>
      <memberdef kind="function" id="group__DictUtils_1ga82da5ec28b359fa7c8800c2c437a438a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void provide_property</definition>
        <argsstring>(DictionaryDatum &amp;, Name, const std::vector&lt; long &gt; &amp;)</argsstring>
        <name>provide_property</name>
        <param>
          <type><ref refid="dictdatum_8h_1a4a4d8eba002ed1473f9f196598b268bc" kindref="member">DictionaryDatum</ref> &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="className" kindref="compound">Name</ref></type>
          <declname>propname</declname>
        </param>
        <param>
          <type>const std::vector&lt; long &gt; &amp;</type>
          <declname>prop</declname>
        </param>
        <briefdescription>
<para>Provide a value to a property IntVectorDatum in the dictionary. </para>
        </briefdescription>
        <detaileddescription>
<para>In contrast to append_property, this function adds the value only once to the property. On all subsequent events, it ensures that the value passed in is identical to the value present. This is needed by recording_decive. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" line="364" column="6" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.cc" bodystart="77" bodyend="91" declfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" declline="364" declcolumn="6"/>
        <references refid="classToken_1a309bb2d7f89471b3aa7ca63cfbde65e4" compoundref="token_8h" startline="360" endline="364">Token::datum</references>
      </memberdef>
      <memberdef kind="function" id="group__DictUtils_1gac6a7e892e132a5b1793361f38f5c3fbe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void accumulate_property</definition>
        <argsstring>(DictionaryDatum &amp;, Name, const std::vector&lt; double &gt; &amp;)</argsstring>
        <name>accumulate_property</name>
        <param>
          <type><ref refid="dictdatum_8h_1a4a4d8eba002ed1473f9f196598b268bc" kindref="member">DictionaryDatum</ref> &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="className" kindref="compound">Name</ref></type>
          <declname>propname</declname>
        </param>
        <param>
          <type>const std::vector&lt; double &gt; &amp;</type>
          <declname>prop</declname>
        </param>
        <briefdescription>
<para>Add values of a vector&lt;double&gt; to a property DoubleVectorDatum in the dictionary. </para>
        </briefdescription>
        <detaileddescription>
<para>This variant of append_property is for adding vector&lt;double&gt;s to vector&lt;double&gt;s of the same size. It is required for collecting data across threads when multimeter is running in accumulation mode. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" line="373" column="6" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.cc" bodystart="94" bodyend="112" declfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.h" declline="373" declcolumn="6"/>
        <references refid="classToken_1a309bb2d7f89471b3aa7ca63cfbde65e4" compoundref="token_8h" startline="360" endline="364">Token::datum</references>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>a dictionary. </para>
    </briefdescription>
    <detaileddescription>
<para>Class <ref refid="classDictionary" kindref="compound">Dictionary</ref> defines the standard user interface for accessing tokens from dictionaries (see there). However, this user interface returns tokens, from which the actual value would still need to be extracted. The utilitiy functions described in this group shortcut this step and provide direct access to the underlying fundamental values associated to a dictionary entry. </para>
    </detaileddescription>
  </compounddef>
</doxygen>
