<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.5" xml:lang="en-US">
  <compounddef id="classSLIArrayModule_1_1Area2Function" kind="class" language="C++" prot="private">
    <compoundname>SLIArrayModule::Area2Function</compoundname>
    <basecompoundref refid="classSLIFunction" prot="public" virt="non-virtual">SLIFunction</basecompoundref>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classSLIArrayModule_1_1Area2Function_1abae669ae9be29d1cfb2ddf9eb2b30763" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void SLIArrayModule::Area2Function::execute</definition>
        <argsstring>(SLIInterpreter *) const override</argsstring>
        <name>execute</name>
        <qualifiedname>SLIArrayModule::Area2Function::execute</qualifiedname>
        <reimplements refid="classSLIFunction_1abb5b37eaff928b43534627ed6f668e7d">execute</reimplements>
        <param>
          <type><ref refid="classSLIInterpreter" kindref="compound">SLIInterpreter</ref> *</type>
          <defname>i</defname>
        </param>
        <briefdescription>
<para>@BeginDocumentation <ref refid="className" kindref="compound">Name</ref>: area2 - Return array of indices defining a 2d subarea of a 2d array. </para>
        </briefdescription>
        <detaileddescription>
<para>Synopsis: source_anchor_y source_anchor_x area_height area_width area_anchor_y area_anchor_x area2 -&gt; [2d-indices]</para>
<para>Description: Given a <ndash/> hypothetical <ndash/> twodimensional array, &quot;area&quot; tells you, what indices you need to subscript a contiguous, twodimensional subarea.</para>
<para>The subarea is defined by specifying it&apos;s size (width and height), as well as its location in the source array. The location is defined by specifying an anchor point in the source array as well as in the subarea. Anchor points are matched, see illustration, and examples below:</para>
<para>source array: height=6, width=15, anchor=(2,5) subarea : height=4, width= 5, anchor=(1,3) ............... ..ooooo........ ..oooxo........ ..ooooo........ ..ooooo........ ...............</para>
<para>&quot;area2&quot; returns an array of TWODIMENSIONAL indices. There is a SLI function called &quot;area&quot; returning onedimensional indices, as well as the conversion functions &quot;cv1d&quot; and &quot;cv2d&quot;. (For information on the order of subscription in NEST arrays, see references below.)</para>
<para>Parameters: In: &quot;area2&quot; takes six integer arguments (three pairs). These arguments describe (1) the height and width of the subarea to be indexed in the (hypothetical) source array, as well as (2&amp;3) an anchor point in each of the two arrays (see illustration above):</para>
<para>source_anchor_y, source_anchor_x: position of the anchor point relative to ORIGIN OF THE SOURCE ARRAY</para>
<para>area_heigh t : height of the subarea to be subscribed area_width : width of the subarea to be subscribed area_anchor_y, area_anchor_x : position of the anchor point relative to ORIGIN OF THE SUBAREA</para>
<para>Out: &quot;area&quot; returns an array of ONEDIMENSIONAL indices: <verbatim>   [2d-indices]   : flat integer array containing the indices
                    that can be used to subscript the
                    (hypothetical) source array in order to
                    access the desired subarea.

                    Indices are twodimensional. The returned
                    array is flat and has the following order:
                    [1y 1x  2y 2x  3y 3x  ...  ny nx]
                    That is, each pair of numbers indicates the
                    y- and the x-component of a respective
                    index.

                    The indices 1..n are returned in standard
                    NEST counting order. (For information on the
                    order of subscription in NEST arrays, see
                    references below.)
</verbatim> Examples: (Examples are illustrated):</para>
<para>Ex. 1: source array: (height=5), (width=10), anchor=(0,0) subarea : height=3, width= 3, anchor=(0,0) xoo....... ooo....... ooo....... .......... ..........</para>
<para>0 0 3 3 0 0 area2 -&gt; [0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2]</para>
<para>Ex. 1b:source array: (height=5), (width=10), anchor=(2,2) subarea : height=3, width= 3, anchor=(2,2) ooo....... ooo....... oox....... .......... ..........</para>
<para>2 2 3 3 2 2 area2 -&gt; [0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2]</para>
<para>Ex. 1c:Note that anchor point may lie outside both arrays&apos; bounds: source array: (height=5), (width=10), anchor=(1,12) subarea : height=3, width= 3, anchor=(1,12) ooo....... ooo....... x ooo....... .......... ..........</para>
<para>1 12 3 3 1 12 area2 -&gt; [0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2]</para>
<para>Ex. 2: source array: (height=6), (width=15), anchor=(2,5) subarea : height=4, width= 5, anchor=(1,3) ............... ..ooooo........ ..oooxo........ ..ooooo........ ..ooooo........ ...............</para>
<para>2 5 4 5 1 3 area2 -&gt; [1 2 1 3 1 4 1 5 1 6 2 2 2 3 2 4 2 5 2 6 3 2 3 3 3 4 3 5 3 6 4 2 4 3 4 4 4 5 4 6]</para>
<para>Ex. 3: Note that subarea doesn&apos;t need to lie inside bounds of source array: source array: (height=4), (width= 8), anchor=(4,-1) subarea : height=2, width= 3, anchor=(1, 0) ........ ........ ........ ooo...... xoo</para>
<para><verbatim>     4 -1  2 3 1 0 area2 -&gt; [3 -1  3 0  3 1
                             4 -1  4 0  4 1]
</verbatim> Diagnostics: &quot;area2&quot; may raise the following SLI interpreter errors: StackUnderflowError ArgumentTypeError</para>
<para>No argument range check is performed. The returned indices may indicate regions outside the source array (see Example 3). This is not a bug, it&apos;s a feature :-). Note that restrictions apply to the related function &quot;area&quot;.</para>
<para>However, anchor points may lie outside the array bounds.</para>
<para>Note that arguments source_width and source_height are not used in computation, and do not appear in the argument list.</para>
<para>Author: Ruediger Kupper</para>
<para>References: (TO BE DONE: NEST layer indexing conventions)</para>
<para>SeeAlso: area </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mitchell/Work/repo/nest-simulator/sli/sliarray.h" line="248" column="10" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/sliarray.cc" bodystart="2305" bodyend="2402"/>
        <references refid="classSLIInterpreter_1a0f433320b9ff523f5e70964bc29af548" compoundref="interpret_8h" startline="148">SLIInterpreter::ArgumentTypeError</references>
        <references refid="classToken_1a309bb2d7f89471b3aa7ca63cfbde65e4" compoundref="token_8h" startline="360" endline="364">Token::datum</references>
        <references refid="classSLIInterpreter_1a3fe2d135bbae0ac57317ff6db9e39055" compoundref="interpret_8h" startline="251">SLIInterpreter::EStack</references>
        <references refid="classGenericDatum_1a2204e0bfb80429863ebbd37005235c1e" compoundref="genericdatum_8h" startline="74" endline="77">GenericDatum&lt; D, slt &gt;::get</references>
        <references refid="classTokenStack_1a9ca4715bf5e4dc851ca0b2c41eb6c586" compoundref="tokenstack_8h" startline="184" endline="187">TokenStack::load</references>
        <references refid="classSLIInterpreter_1aafcfa7e2b250f23f2c66af03f0fea32e" compoundref="interpret_8h" startline="181">SLIInterpreter::M_ERROR</references>
        <references refid="group__SLIMessaging_1gacbc035efd87bf843002900f7f1baf5b0" compoundref="interpret_8cc" startline="774" endline="824">SLIInterpreter::message</references>
        <references refid="classSLIInterpreter_1ab50b50d10259d50fd78939273af5e4f5" compoundref="interpret_8h" startline="250">SLIInterpreter::OStack</references>
        <references refid="classTokenStack_1ac861cc2282484dd2a27dd1304aa719a4" compoundref="tokenstack_8h" startline="127" endline="130">TokenStack::pick</references>
        <references refid="classTokenStack_1a759f4b3c1c8955ab6f236de28a7f1cc0" compoundref="tokenstack_8h" startline="96" endline="99">TokenStack::pop</references>
        <references refid="classTokenArray_1acbf2202157ead1bb583c43a8465b3876" compoundref="tokenarray_8h" startline="266" endline="270">TokenArray::push_back</references>
        <references refid="classTokenStack_1a75a8af662288b54a64d5185c90401dec" compoundref="tokenstack_8h" startline="90" endline="93">TokenStack::push_by_pointer</references>
        <references refid="group__SLIError_1ga458cc1c0524cbf3902a74a835e9214e6" compoundref="interpret_8h" startline="635" endline="638">SLIInterpreter::raiseerror</references>
        <references refid="classTokenArray_1a8bae8fd6f068f93a2acd614f724486e2" compoundref="tokenarray_8h" startline="241" endline="244">TokenArray::reserve</references>
        <references refid="classSLIInterpreter_1af98b93bb76491e6bc67e7636ca8e9ea9" compoundref="interpret_8h" startline="149">SLIInterpreter::StackUnderflowError</references>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Return array of indices defining a 2d subarea of a 2d array. </para>
    </briefdescription>
    <detaileddescription>
<para>Given a <ndash/> hypothetical <ndash/> twodimensional array, &quot;area&quot; tells you, what indices you need to subscript a contiguous, twodimensional subarea. Returns 2-d indices.</para>
<para>For further information refer to the SLI documentation.</para>
<para><simplesect kind="par"><title>Synopsis:</title><para>source_anchor_y source_anchor_x area_height area_width area_anchor_y area_anchor_x area -&gt; *[1d-indices]</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>source_anchor_y</parametername>
</parameternamelist>
<parameterdescription>
<para>y position of the anchor point relative to ORIGIN OF THE SOURCE ARRAY </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>source_anchor_x</parametername>
</parameternamelist>
<parameterdescription>
<para>x position of the anchor point relative to ORIGIN OF THE SOURCE ARRAY</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>area_height</parametername>
</parameternamelist>
<parameterdescription>
<para>height of the subarea to be subscribed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>area_width</parametername>
</parameternamelist>
<parameterdescription>
<para>width of the subarea to be subscribed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>area_anchor_y</parametername>
</parameternamelist>
<parameterdescription>
<para>y position of the anchor point relative to ORIGIN OF THE SUBAREA </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>area_anchor_x</parametername>
</parameternamelist>
<parameterdescription>
<para>x position of the anchor point relative to ORIGIN OF THE SUBAREA</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><emphasis></emphasis>[2d-indices] flat integer array containing the indices that can be used to subscript the (hypothetical) source array in order to access the desired subarea. </para>
</simplesect>
</para>
    </detaileddescription>
    <inheritancegraph>
      <node id="1">
        <label>SLIArrayModule::Area2Function</label>
        <link refid="classSLIArrayModule_1_1Area2Function"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>SLIFunction</label>
        <link refid="classSLIFunction"/>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="1">
        <label>SLIArrayModule::Area2Function</label>
        <link refid="classSLIArrayModule_1_1Area2Function"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>SLIFunction</label>
        <link refid="classSLIFunction"/>
      </node>
    </collaborationgraph>
    <location file="/home/mitchell/Work/repo/nest-simulator/sli/sliarray.h" line="245" column="3" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/sliarray.h" bodystart="246" bodyend="249"/>
    <listofallmembers>
      <member refid="classSLIFunction_1a68fd2ac46dd904673f3a8c96009221ba" prot="public" virt="virtual"><scope>SLIArrayModule::Area2Function</scope><name>backtrace</name></member>
      <member refid="classSLIArrayModule_1_1Area2Function_1abae669ae9be29d1cfb2ddf9eb2b30763" prot="public" virt="virtual"><scope>SLIArrayModule::Area2Function</scope><name>execute</name></member>
      <member refid="classSLIFunction_1a3c4393dfc6f80af057a81d34a1a8bbad" prot="public" virt="non-virtual"><scope>SLIArrayModule::Area2Function</scope><name>SLIFunction</name></member>
      <member refid="classSLIFunction_1a1d35138a5956abbaf4a57d051bcb397b" prot="public" virt="virtual"><scope>SLIArrayModule::Area2Function</scope><name>~SLIFunction</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
