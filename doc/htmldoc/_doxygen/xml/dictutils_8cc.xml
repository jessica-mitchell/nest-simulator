<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.5" xml:lang="en-US">
  <compounddef id="dictutils_8cc" kind="file" language="C++">
    <compoundname>dictutils.cc</compoundname>
    <includes refid="dictutils_8h" local="yes">dictutils.h</includes>
    <incdepgraph>
      <node id="35">
        <label>lockptr.h</label>
        <link refid="lockptr_8h"/>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="31" relation="include">
        </childnode>
        <childnode refid="36" relation="include">
        </childnode>
      </node>
      <node id="9">
        <label>aggregatedatum.h</label>
        <link refid="aggregatedatum_8h"/>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="14" relation="include">
        </childnode>
      </node>
      <node id="11">
        <label>allocator.h</label>
        <link refid="allocator_8h"/>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
      </node>
      <node id="7">
        <label>arraydatum.h</label>
        <link refid="arraydatum_8h"/>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="22" relation="include">
        </childnode>
        <childnode refid="34" relation="include">
        </childnode>
        <childnode refid="32" relation="include">
        </childnode>
      </node>
      <node id="14">
        <label>datum.h</label>
        <link refid="datum_8h"/>
        <childnode refid="15" relation="include">
        </childnode>
      </node>
      <node id="38">
        <label>dict.h</label>
        <link refid="dict_8h"/>
        <childnode refid="20" relation="include">
        </childnode>
        <childnode refid="18" relation="include">
        </childnode>
        <childnode refid="33" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
      </node>
      <node id="37">
        <label>dictdatum.h</label>
        <link refid="dictdatum_8h"/>
        <childnode refid="38" relation="include">
        </childnode>
        <childnode refid="22" relation="include">
        </childnode>
        <childnode refid="34" relation="include">
        </childnode>
      </node>
      <node id="1">
        <label>dictutils.cc</label>
        <link refid="dictutils_8cc"/>
        <childnode refid="2" relation="include">
        </childnode>
      </node>
      <node id="2">
        <label>dictutils.h</label>
        <link refid="dictutils_8h"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="37" relation="include">
        </childnode>
        <childnode refid="39" relation="include">
        </childnode>
        <childnode refid="42" relation="include">
        </childnode>
        <childnode refid="43" relation="include">
        </childnode>
        <childnode refid="44" relation="include">
        </childnode>
      </node>
      <node id="39">
        <label>doubledatum.h</label>
        <link refid="doubledatum_8h"/>
        <childnode refid="14" relation="include">
        </childnode>
        <childnode refid="22" relation="include">
        </childnode>
        <childnode refid="40" relation="include">
        </childnode>
      </node>
      <node id="41">
        <label>genericdatum.h</label>
        <link refid="genericdatum_8h"/>
        <childnode refid="14" relation="include">
        </childnode>
      </node>
      <node id="42">
        <label>integerdatum.h</label>
        <link refid="integerdatum_8h"/>
        <childnode refid="22" relation="include">
        </childnode>
        <childnode refid="40" relation="include">
        </childnode>
      </node>
      <node id="22">
        <label>interpret.h</label>
        <link refid="interpret_8h"/>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="17" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="15" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
      </node>
      <node id="34">
        <label>lockptrdatum.h</label>
        <link refid="lockptrdatum_8h"/>
        <childnode refid="35" relation="include">
        </childnode>
        <childnode refid="14" relation="include">
        </childnode>
      </node>
      <node id="18">
        <label>name.h</label>
        <link refid="name_8h"/>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="19" relation="include">
        </childnode>
        <childnode refid="16" relation="include">
        </childnode>
        <childnode refid="20" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
      </node>
      <node id="43">
        <label>namedatum.h</label>
        <link refid="namedatum_8h"/>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="17" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="22" relation="include">
        </childnode>
        <childnode refid="18" relation="include">
        </childnode>
      </node>
      <node id="40">
        <label>numericdatum.h</label>
        <link refid="numericdatum_8h"/>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
      </node>
      <node id="24">
        <label>sliactions.h</label>
        <link refid="sliactions_8h"/>
        <childnode refid="21" relation="include">
        </childnode>
      </node>
      <node id="25">
        <label>slibuiltins.h</label>
        <link refid="slibuiltins_8h"/>
        <childnode refid="17" relation="include">
        </childnode>
        <childnode refid="21" relation="include">
        </childnode>
      </node>
      <node id="33">
        <label>sliexceptions.h</label>
        <link refid="sliexceptions_8h"/>
        <childnode refid="16" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="18" relation="include">
        </childnode>
      </node>
      <node id="21">
        <label>slifunction.h</label>
        <link refid="slifunction_8h"/>
      </node>
      <node id="26">
        <label>slimodule.h</label>
        <link refid="slimodule_8h"/>
        <childnode refid="16" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
      </node>
      <node id="15">
        <label>slitype.h</label>
        <link refid="slitype_8h"/>
        <childnode refid="16" relation="include">
        </childnode>
        <childnode refid="17" relation="include">
        </childnode>
        <childnode refid="18" relation="include">
        </childnode>
        <childnode refid="21" relation="include">
        </childnode>
      </node>
      <node id="30">
        <label>tarrayobj.h</label>
        <link refid="tarrayobj_8h"/>
        <childnode refid="31" relation="include">
        </childnode>
        <childnode refid="17" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
      </node>
      <node id="27">
        <label>token.h</label>
        <link refid="token_8h"/>
        <childnode refid="28" relation="include">
        </childnode>
        <childnode refid="16" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="17" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="14" relation="include">
        </childnode>
      </node>
      <node id="32">
        <label>tokenarray.h</label>
        <link refid="tokenarray_8h"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="31" relation="include">
        </childnode>
        <childnode refid="17" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="33" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
      </node>
      <node id="29">
        <label>tokenstack.h</label>
        <link refid="tokenstack_8h"/>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="32" relation="include">
        </childnode>
      </node>
      <node id="44">
        <label>tokenutils.h</label>
        <link refid="tokenutils_8h"/>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="43" relation="include">
        </childnode>
        <childnode refid="33" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
      </node>
      <node id="3">
        <label>algorithm</label>
      </node>
      <node id="12">
        <label>cassert</label>
      </node>
      <node id="10">
        <label>config.h</label>
      </node>
      <node id="31">
        <label>cstddef</label>
      </node>
      <node id="13">
        <label>cstdlib</label>
      </node>
      <node id="19">
        <label>deque</label>
      </node>
      <node id="4">
        <label>functional</label>
      </node>
      <node id="28">
        <label>iomanip</label>
      </node>
      <node id="16">
        <label>iostream</label>
      </node>
      <node id="5">
        <label>limits</label>
      </node>
      <node id="23">
        <label>list</label>
      </node>
      <node id="20">
        <label>map</label>
      </node>
      <node id="36">
        <label>memory</label>
      </node>
      <node id="6">
        <label>string</label>
      </node>
      <node id="17">
        <label>typeinfo</label>
      </node>
      <node id="8">
        <label>vector</label>
      </node>
    </incdepgraph>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__DictUtils_1gaeb39309693e8740af1323d58dae4277f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void initialize_property_array</definition>
        <argsstring>(DictionaryDatum &amp;d, Name propname)</argsstring>
        <name>initialize_property_array</name>
        <param>
          <type><ref refid="dictdatum_8h_1a4a4d8eba002ed1473f9f196598b268bc" kindref="member">DictionaryDatum</ref> &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="className" kindref="compound">Name</ref></type>
          <declname>propname</declname>
        </param>
        <briefdescription>
<para>Create a property of type ArrayDatum in the dictionary, if it does not already exist. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.cc" line="26" column="1" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.cc" bodystart="26" bodyend="34"/>
        <references refid="classToken_1a397db8062278fec3e786aa62f9d9baf8" compoundref="token_8h" startline="348" endline="351">Token::empty</references>
        <references refid="className_1a8ee5a44599eb7a686ee64c343e0c8e18" compoundref="name_8h" startline="118" endline="122">Name::lookup</references>
        <referencedby refid="structnest_1_1RecordingBackendASCII_1_1DeviceData_1a64219cbc9de401ebd5677b8a3cef4afe" compoundref="recording__backend__ascii_8cpp" startline="326" endline="335">nest::RecordingBackendASCII::DeviceData::get_status</referencedby>
      </memberdef>
      <memberdef kind="function" id="group__DictUtils_1gaca5cefae6151612dea3da39adc295c78" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void initialize_property_doublevector</definition>
        <argsstring>(DictionaryDatum &amp;d, Name propname)</argsstring>
        <name>initialize_property_doublevector</name>
        <param>
          <type><ref refid="dictdatum_8h_1a4a4d8eba002ed1473f9f196598b268bc" kindref="member">DictionaryDatum</ref> &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="className" kindref="compound">Name</ref></type>
          <declname>propname</declname>
        </param>
        <briefdescription>
<para>Create a property of type DoubleVectorDatum in the dictionary, if it does not already exist. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.cc" line="37" column="1" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.cc" bodystart="37" bodyend="45"/>
        <references refid="classToken_1a397db8062278fec3e786aa62f9d9baf8" compoundref="token_8h" startline="348" endline="351">Token::empty</references>
        <references refid="className_1a8ee5a44599eb7a686ee64c343e0c8e18" compoundref="name_8h" startline="118" endline="122">Name::lookup</references>
        <referencedby refid="structnest_1_1RecordingBackendMemory_1_1DeviceData_1a59027dbfb942b3b10b6c09265bbfb14c" compoundref="recording__backend__memory_8cpp" startline="218" endline="261">nest::RecordingBackendMemory::DeviceData::get_status</referencedby>
      </memberdef>
      <memberdef kind="function" id="group__DictUtils_1gadc6126c32cd382bccbcfbc788c6f650f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void initialize_property_intvector</definition>
        <argsstring>(DictionaryDatum &amp;d, Name propname)</argsstring>
        <name>initialize_property_intvector</name>
        <param>
          <type><ref refid="dictdatum_8h_1a4a4d8eba002ed1473f9f196598b268bc" kindref="member">DictionaryDatum</ref> &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="className" kindref="compound">Name</ref></type>
          <declname>propname</declname>
        </param>
        <briefdescription>
<para>Create a property of type IntVectorDatum in the dictionary, if it does not already exist. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.cc" line="48" column="1" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.cc" bodystart="48" bodyend="56"/>
        <references refid="classToken_1a397db8062278fec3e786aa62f9d9baf8" compoundref="token_8h" startline="348" endline="351">Token::empty</references>
        <references refid="className_1a8ee5a44599eb7a686ee64c343e0c8e18" compoundref="name_8h" startline="118" endline="122">Name::lookup</references>
        <referencedby refid="structnest_1_1RecordingBackendMemory_1_1DeviceData_1a59027dbfb942b3b10b6c09265bbfb14c" compoundref="recording__backend__memory_8cpp" startline="218" endline="261">nest::RecordingBackendMemory::DeviceData::get_status</referencedby>
      </memberdef>
      <memberdef kind="function" id="group__DictUtils_1gab7a520a9b1a45325ab4fcc550dee5e9b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void provide_property</definition>
        <argsstring>(DictionaryDatum &amp;d, Name propname, const std::vector&lt; double &gt; &amp;prop)</argsstring>
        <name>provide_property</name>
        <param>
          <type><ref refid="dictdatum_8h_1a4a4d8eba002ed1473f9f196598b268bc" kindref="member">DictionaryDatum</ref> &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="className" kindref="compound">Name</ref></type>
          <declname>propname</declname>
        </param>
        <param>
          <type>const std::vector&lt; double &gt; &amp;</type>
          <declname>prop</declname>
        </param>
        <briefdescription>
<para>Provide a value to a property DoubleVectorDatum in the dictionary. </para>
        </briefdescription>
        <detaileddescription>
<para>In contrast to append_property, this function adds the value only once to the property. On all subsequent events, it ensures that the value passed in is identical to the value present. This is needed by recording_decive. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.cc" line="59" column="1" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.cc" bodystart="59" bodyend="73"/>
        <references refid="classToken_1a309bb2d7f89471b3aa7ca63cfbde65e4" compoundref="token_8h" startline="360" endline="364">Token::datum</references>
      </memberdef>
      <memberdef kind="function" id="group__DictUtils_1ga82da5ec28b359fa7c8800c2c437a438a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void provide_property</definition>
        <argsstring>(DictionaryDatum &amp;d, Name propname, const std::vector&lt; long &gt; &amp;prop)</argsstring>
        <name>provide_property</name>
        <param>
          <type><ref refid="dictdatum_8h_1a4a4d8eba002ed1473f9f196598b268bc" kindref="member">DictionaryDatum</ref> &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="className" kindref="compound">Name</ref></type>
          <declname>propname</declname>
        </param>
        <param>
          <type>const std::vector&lt; long &gt; &amp;</type>
          <declname>prop</declname>
        </param>
        <briefdescription>
<para>Provide a value to a property IntVectorDatum in the dictionary. </para>
        </briefdescription>
        <detaileddescription>
<para>In contrast to append_property, this function adds the value only once to the property. On all subsequent events, it ensures that the value passed in is identical to the value present. This is needed by recording_decive. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.cc" line="77" column="1" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.cc" bodystart="77" bodyend="91"/>
        <references refid="classToken_1a309bb2d7f89471b3aa7ca63cfbde65e4" compoundref="token_8h" startline="360" endline="364">Token::datum</references>
      </memberdef>
      <memberdef kind="function" id="group__DictUtils_1gac6a7e892e132a5b1793361f38f5c3fbe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void accumulate_property</definition>
        <argsstring>(DictionaryDatum &amp;d, Name propname, const std::vector&lt; double &gt; &amp;prop)</argsstring>
        <name>accumulate_property</name>
        <param>
          <type><ref refid="dictdatum_8h_1a4a4d8eba002ed1473f9f196598b268bc" kindref="member">DictionaryDatum</ref> &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="className" kindref="compound">Name</ref></type>
          <declname>propname</declname>
        </param>
        <param>
          <type>const std::vector&lt; double &gt; &amp;</type>
          <declname>prop</declname>
        </param>
        <briefdescription>
<para>Add values of a vector&lt;double&gt; to a property DoubleVectorDatum in the dictionary. </para>
        </briefdescription>
        <detaileddescription>
<para>This variant of append_property is for adding vector&lt;double&gt;s to vector&lt;double&gt;s of the same size. It is required for collecting data across threads when multimeter is running in accumulation mode. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.cc" line="94" column="1" bodyfile="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.cc" bodystart="94" bodyend="112"/>
        <references refid="classToken_1a309bb2d7f89471b3aa7ca63cfbde65e4" compoundref="token_8h" startline="360" endline="364">Token::datum</references>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">/*</highlight></codeline>
<codeline lineno="2"><highlight class="comment"><sp/>*<sp/><sp/>dictutils.cc</highlight></codeline>
<codeline lineno="3"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="4"><highlight class="comment"><sp/>*<sp/><sp/>This<sp/>file<sp/>is<sp/>part<sp/>of<sp/>NEST.</highlight></codeline>
<codeline lineno="5"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="6"><highlight class="comment"><sp/>*<sp/><sp/>Copyright<sp/>(C)<sp/>2004<sp/>The<sp/>NEST<sp/>Initiative</highlight></codeline>
<codeline lineno="7"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="8"><highlight class="comment"><sp/>*<sp/><sp/>NEST<sp/>is<sp/>free<sp/>software:<sp/>you<sp/>can<sp/>redistribute<sp/>it<sp/>and/or<sp/>modify</highlight></codeline>
<codeline lineno="9"><highlight class="comment"><sp/>*<sp/><sp/>it<sp/>under<sp/>the<sp/>terms<sp/>of<sp/>the<sp/>GNU<sp/>General<sp/>Public<sp/>License<sp/>as<sp/>published<sp/>by</highlight></codeline>
<codeline lineno="10"><highlight class="comment"><sp/>*<sp/><sp/>the<sp/>Free<sp/>Software<sp/>Foundation,<sp/>either<sp/>version<sp/>2<sp/>of<sp/>the<sp/>License,<sp/>or</highlight></codeline>
<codeline lineno="11"><highlight class="comment"><sp/>*<sp/><sp/>(at<sp/>your<sp/>option)<sp/>any<sp/>later<sp/>version.</highlight></codeline>
<codeline lineno="12"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="13"><highlight class="comment"><sp/>*<sp/><sp/>NEST<sp/>is<sp/>distributed<sp/>in<sp/>the<sp/>hope<sp/>that<sp/>it<sp/>will<sp/>be<sp/>useful,</highlight></codeline>
<codeline lineno="14"><highlight class="comment"><sp/>*<sp/><sp/>but<sp/>WITHOUT<sp/>ANY<sp/>WARRANTY;<sp/>without<sp/>even<sp/>the<sp/>implied<sp/>warranty<sp/>of</highlight></codeline>
<codeline lineno="15"><highlight class="comment"><sp/>*<sp/><sp/>MERCHANTABILITY<sp/>or<sp/>FITNESS<sp/>FOR<sp/>A<sp/>PARTICULAR<sp/>PURPOSE.<sp/><sp/>See<sp/>the</highlight></codeline>
<codeline lineno="16"><highlight class="comment"><sp/>*<sp/><sp/>GNU<sp/>General<sp/>Public<sp/>License<sp/>for<sp/>more<sp/>details.</highlight></codeline>
<codeline lineno="17"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="18"><highlight class="comment"><sp/>*<sp/><sp/>You<sp/>should<sp/>have<sp/>received<sp/>a<sp/>copy<sp/>of<sp/>the<sp/>GNU<sp/>General<sp/>Public<sp/>License</highlight></codeline>
<codeline lineno="19"><highlight class="comment"><sp/>*<sp/><sp/>along<sp/>with<sp/>NEST.<sp/><sp/>If<sp/>not,<sp/>see<sp/>&lt;http://www.gnu.org/licenses/&gt;.</highlight></codeline>
<codeline lineno="20"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="21"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="22"><highlight class="normal"></highlight></codeline>
<codeline lineno="23"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="dictutils_8h" kindref="compound">dictutils.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="24"><highlight class="normal"></highlight></codeline>
<codeline lineno="25"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="26" refid="group__DictUtils_1gaeb39309693e8740af1323d58dae4277f" refkind="member"><highlight class="normal"><ref refid="group__DictUtils_1gaeb39309693e8740af1323d58dae4277f" kindref="member">initialize_property_array</ref>(<sp/><ref refid="classlockPTRDatum" kindref="compound">DictionaryDatum</ref>&amp;<sp/>d,<sp/><ref refid="className" kindref="compound">Name</ref><sp/>propname<sp/>)</highlight></codeline>
<codeline lineno="27"><highlight class="normal">{</highlight></codeline>
<codeline lineno="28"><highlight class="normal"><sp/><sp/><ref refid="classToken" kindref="compound">Token</ref><sp/>t<sp/>=<sp/>d-&gt;<ref refid="className_1a8ee5a44599eb7a686ee64c343e0c8e18" kindref="member">lookup</ref>(<sp/>propname<sp/>);</highlight></codeline>
<codeline lineno="29"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>t.<ref refid="classToken_1a397db8062278fec3e786aa62f9d9baf8" kindref="member">empty</ref>()<sp/>)</highlight></codeline>
<codeline lineno="30"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="31"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classAggregateDatum" kindref="compound">ArrayDatum</ref><sp/>arrd;</highlight></codeline>
<codeline lineno="32"><highlight class="normal"><sp/><sp/><sp/><sp/>def&lt;<sp/>ArrayDatum<sp/>&gt;(<sp/>d,<sp/>propname,<sp/>arrd<sp/>);</highlight></codeline>
<codeline lineno="33"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="34"><highlight class="normal">}</highlight></codeline>
<codeline lineno="35"><highlight class="normal"></highlight></codeline>
<codeline lineno="36"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="37" refid="group__DictUtils_1gaca5cefae6151612dea3da39adc295c78" refkind="member"><highlight class="normal"><ref refid="group__DictUtils_1gaca5cefae6151612dea3da39adc295c78" kindref="member">initialize_property_doublevector</ref>(<sp/><ref refid="classlockPTRDatum" kindref="compound">DictionaryDatum</ref>&amp;<sp/>d,<sp/><ref refid="className" kindref="compound">Name</ref><sp/>propname<sp/>)</highlight></codeline>
<codeline lineno="38"><highlight class="normal">{</highlight></codeline>
<codeline lineno="39"><highlight class="normal"><sp/><sp/><ref refid="classToken" kindref="compound">Token</ref><sp/>t<sp/>=<sp/>d-&gt;<ref refid="className_1a8ee5a44599eb7a686ee64c343e0c8e18" kindref="member">lookup</ref>(<sp/>propname<sp/>);</highlight></codeline>
<codeline lineno="40"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>t.<ref refid="classToken_1a397db8062278fec3e786aa62f9d9baf8" kindref="member">empty</ref>()<sp/>)</highlight></codeline>
<codeline lineno="41"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="42"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classlockPTRDatum" kindref="compound">DoubleVectorDatum</ref><sp/>arrd(<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>std::vector&lt;<sp/>double<sp/>&gt;<sp/>);</highlight></codeline>
<codeline lineno="43"><highlight class="normal"><sp/><sp/><sp/><sp/>def&lt;<sp/>DoubleVectorDatum<sp/>&gt;(<sp/>d,<sp/>propname,<sp/>arrd<sp/>);</highlight></codeline>
<codeline lineno="44"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="45"><highlight class="normal">}</highlight></codeline>
<codeline lineno="46"><highlight class="normal"></highlight></codeline>
<codeline lineno="47"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="48" refid="group__DictUtils_1gadc6126c32cd382bccbcfbc788c6f650f" refkind="member"><highlight class="normal"><ref refid="group__DictUtils_1gadc6126c32cd382bccbcfbc788c6f650f" kindref="member">initialize_property_intvector</ref>(<sp/><ref refid="classlockPTRDatum" kindref="compound">DictionaryDatum</ref>&amp;<sp/>d,<sp/><ref refid="className" kindref="compound">Name</ref><sp/>propname<sp/>)</highlight></codeline>
<codeline lineno="49"><highlight class="normal">{</highlight></codeline>
<codeline lineno="50"><highlight class="normal"><sp/><sp/><ref refid="classToken" kindref="compound">Token</ref><sp/>t<sp/>=<sp/>d-&gt;<ref refid="className_1a8ee5a44599eb7a686ee64c343e0c8e18" kindref="member">lookup</ref>(<sp/>propname<sp/>);</highlight></codeline>
<codeline lineno="51"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>t.<ref refid="classToken_1a397db8062278fec3e786aa62f9d9baf8" kindref="member">empty</ref>()<sp/>)</highlight></codeline>
<codeline lineno="52"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="53"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classlockPTRDatum" kindref="compound">IntVectorDatum</ref><sp/>arrd(<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>std::vector&lt;<sp/>long<sp/>&gt;<sp/>);</highlight></codeline>
<codeline lineno="54"><highlight class="normal"><sp/><sp/><sp/><sp/>def&lt;<sp/>IntVectorDatum<sp/>&gt;(<sp/>d,<sp/>propname,<sp/>arrd<sp/>);</highlight></codeline>
<codeline lineno="55"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="56"><highlight class="normal">}</highlight></codeline>
<codeline lineno="57"><highlight class="normal"></highlight></codeline>
<codeline lineno="58"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="59" refid="group__DictUtils_1gab7a520a9b1a45325ab4fcc550dee5e9b" refkind="member"><highlight class="normal"><ref refid="group__DictUtils_1gab7a520a9b1a45325ab4fcc550dee5e9b" kindref="member">provide_property</ref>(<sp/><ref refid="classlockPTRDatum" kindref="compound">DictionaryDatum</ref>&amp;<sp/>d,<sp/><ref refid="className" kindref="compound">Name</ref><sp/>propname,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;<sp/>double<sp/>&gt;&amp;<sp/>prop<sp/>)</highlight></codeline>
<codeline lineno="60"><highlight class="normal">{</highlight></codeline>
<codeline lineno="61"><highlight class="normal"><sp/><sp/><ref refid="classToken" kindref="compound">Token</ref><sp/>t<sp/>=<sp/>d-&gt;lookup2(<sp/>propname<sp/>);</highlight></codeline>
<codeline lineno="62"><highlight class="normal"></highlight></codeline>
<codeline lineno="63"><highlight class="normal"><sp/><sp/><ref refid="classlockPTRDatum" kindref="compound">DoubleVectorDatum</ref>*<sp/>arrd<sp/>=<sp/></highlight><highlight class="keyword">dynamic_cast&lt;</highlight><highlight class="normal"><sp/><ref refid="classlockPTRDatum" kindref="compound">DoubleVectorDatum</ref>*<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(<sp/>t.<ref refid="classToken_1a309bb2d7f89471b3aa7ca63cfbde65e4" kindref="member">datum</ref>()<sp/>);</highlight></codeline>
<codeline lineno="64"><highlight class="normal"><sp/><sp/>assert(<sp/>arrd<sp/>);</highlight></codeline>
<codeline lineno="65"><highlight class="normal"></highlight></codeline>
<codeline lineno="66"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>(<sp/>*arrd<sp/>)-&gt;empty()<sp/>and<sp/>not<sp/>prop.empty()<sp/>)<sp/></highlight><highlight class="comment">//<sp/>not<sp/>data<sp/>from<sp/>before,<sp/>add</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/><sp/><sp/>(<sp/>*arrd<sp/>)-&gt;insert(<sp/>(<sp/>*arrd<sp/>)-&gt;end(),<sp/>prop.begin(),<sp/>prop.end()<sp/>);</highlight></codeline>
<codeline lineno="69"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="70"><highlight class="normal"></highlight></codeline>
<codeline lineno="71"><highlight class="normal"><sp/><sp/>assert(<sp/>prop.empty()<sp/>or<sp/>**arrd<sp/>==<sp/>prop<sp/>);<sp/></highlight><highlight class="comment">//<sp/>not<sp/>testing<sp/>for<sp/>**arrd.empty()</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="72"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>since<sp/>that<sp/>implies<sp/>prop.empty()</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="73"><highlight class="normal">}</highlight></codeline>
<codeline lineno="74"><highlight class="normal"></highlight></codeline>
<codeline lineno="75"><highlight class="normal"></highlight></codeline>
<codeline lineno="76"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="77" refid="group__DictUtils_1ga82da5ec28b359fa7c8800c2c437a438a" refkind="member"><highlight class="normal"><ref refid="group__DictUtils_1gab7a520a9b1a45325ab4fcc550dee5e9b" kindref="member">provide_property</ref>(<sp/><ref refid="classlockPTRDatum" kindref="compound">DictionaryDatum</ref>&amp;<sp/>d,<sp/><ref refid="className" kindref="compound">Name</ref><sp/>propname,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;<sp/>long<sp/>&gt;&amp;<sp/>prop<sp/>)</highlight></codeline>
<codeline lineno="78"><highlight class="normal">{</highlight></codeline>
<codeline lineno="79"><highlight class="normal"><sp/><sp/><ref refid="classToken" kindref="compound">Token</ref><sp/>t<sp/>=<sp/>d-&gt;lookup2(<sp/>propname<sp/>);</highlight></codeline>
<codeline lineno="80"><highlight class="normal"></highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/><ref refid="classlockPTRDatum" kindref="compound">IntVectorDatum</ref>*<sp/>arrd<sp/>=<sp/></highlight><highlight class="keyword">dynamic_cast&lt;</highlight><highlight class="normal"><sp/><ref refid="classlockPTRDatum" kindref="compound">IntVectorDatum</ref>*<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(<sp/>t.<ref refid="classToken_1a309bb2d7f89471b3aa7ca63cfbde65e4" kindref="member">datum</ref>()<sp/>);</highlight></codeline>
<codeline lineno="82"><highlight class="normal"><sp/><sp/>assert(<sp/>arrd<sp/>);</highlight></codeline>
<codeline lineno="83"><highlight class="normal"></highlight></codeline>
<codeline lineno="84"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>(<sp/>*arrd<sp/>)-&gt;empty()<sp/>and<sp/>not<sp/>prop.empty()<sp/>)<sp/></highlight><highlight class="comment">//<sp/>not<sp/>data<sp/>from<sp/>before,<sp/>add</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="85"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="86"><highlight class="normal"><sp/><sp/><sp/><sp/>(<sp/>*arrd<sp/>)-&gt;insert(<sp/>(<sp/>*arrd<sp/>)-&gt;end(),<sp/>prop.begin(),<sp/>prop.end()<sp/>);</highlight></codeline>
<codeline lineno="87"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="88"><highlight class="normal"></highlight></codeline>
<codeline lineno="89"><highlight class="normal"><sp/><sp/>assert(<sp/>prop.empty()<sp/>or<sp/>**arrd<sp/>==<sp/>prop<sp/>);<sp/></highlight><highlight class="comment">//<sp/>not<sp/>testing<sp/>for<sp/>**arrd.empty()</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="90"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>since<sp/>that<sp/>implies<sp/>prop.empty()</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="91"><highlight class="normal">}</highlight></codeline>
<codeline lineno="92"><highlight class="normal"></highlight></codeline>
<codeline lineno="93"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="94" refid="group__DictUtils_1gac6a7e892e132a5b1793361f38f5c3fbe" refkind="member"><highlight class="normal"><ref refid="group__DictUtils_1gac6a7e892e132a5b1793361f38f5c3fbe" kindref="member">accumulate_property</ref>(<sp/><ref refid="classlockPTRDatum" kindref="compound">DictionaryDatum</ref>&amp;<sp/>d,<sp/><ref refid="className" kindref="compound">Name</ref><sp/>propname,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;<sp/>double<sp/>&gt;&amp;<sp/>prop<sp/>)</highlight></codeline>
<codeline lineno="95"><highlight class="normal">{</highlight></codeline>
<codeline lineno="96"><highlight class="normal"><sp/><sp/><ref refid="classToken" kindref="compound">Token</ref><sp/>t<sp/>=<sp/>d-&gt;lookup2(<sp/>propname<sp/>);</highlight></codeline>
<codeline lineno="97"><highlight class="normal"></highlight></codeline>
<codeline lineno="98"><highlight class="normal"><sp/><sp/><ref refid="classlockPTRDatum" kindref="compound">DoubleVectorDatum</ref>*<sp/>arrd<sp/>=<sp/></highlight><highlight class="keyword">dynamic_cast&lt;</highlight><highlight class="normal"><sp/><ref refid="classlockPTRDatum" kindref="compound">DoubleVectorDatum</ref>*<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(<sp/>t.<ref refid="classToken_1a309bb2d7f89471b3aa7ca63cfbde65e4" kindref="member">datum</ref>()<sp/>);</highlight></codeline>
<codeline lineno="99"><highlight class="normal"><sp/><sp/>assert(<sp/>arrd<sp/>);</highlight></codeline>
<codeline lineno="100"><highlight class="normal"></highlight></codeline>
<codeline lineno="101"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>(<sp/>*arrd<sp/>)-&gt;empty()<sp/>)<sp/></highlight><highlight class="comment">//<sp/>first<sp/>data,<sp/>copy</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="102"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/><sp/><sp/>(<sp/>*arrd<sp/>)-&gt;insert(<sp/>(<sp/>*arrd<sp/>)-&gt;end(),<sp/>prop.begin(),<sp/>prop.end()<sp/>);</highlight></codeline>
<codeline lineno="104"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="105"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="106"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/><sp/><sp/>assert(<sp/>(<sp/>*arrd<sp/>)-&gt;size()<sp/>==<sp/>prop.size()<sp/>);</highlight></codeline>
<codeline lineno="108"><highlight class="normal"></highlight></codeline>
<codeline lineno="109"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>add<sp/>contents<sp/>of<sp/>prop<sp/>to<sp/>**arrd<sp/>elementwise</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="110"><highlight class="normal"><sp/><sp/><sp/><sp/>std::transform(<sp/>(<sp/>*arrd<sp/>)-&gt;begin(),<sp/>(<sp/>*arrd<sp/>)-&gt;end(),<sp/>prop.begin(),<sp/>(<sp/>*arrd<sp/>)-&gt;begin(),<sp/>std::plus&lt;<sp/>double<sp/>&gt;()<sp/>);</highlight></codeline>
<codeline lineno="111"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="112"><highlight class="normal">}</highlight></codeline>
    </programlisting>
    <location file="/home/mitchell/Work/repo/nest-simulator/sli/dictutils.cc"/>
  </compounddef>
</doxygen>
