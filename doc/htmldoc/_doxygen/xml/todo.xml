<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.5" xml:lang="en-US">
  <compounddef id="todo" kind="page">
    <compoundname>todo</compoundname>
    <title>Todo List</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><variablelist>
<varlistentry><term>Member <ref refid="classDictionary_1a3c26795421861bc5ab7e14cab352a97d" kindref="member">Dictionary::add_dict</ref>  (const std::string &amp;, <ref refid="classSLIInterpreter" kindref="compound">SLIInterpreter</ref> &amp;)</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000016"/>Allow for free formatting of target dictionary entries via functor, and add traits to allow duplicates.  </para>
</listitem>
<varlistentry><term>Class <ref refid="classDynamicModuleManagementError" kindref="compound">DynamicModuleManagementError</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000019"/>Shouldn&apos;t this be a KernelException?  </para>
</listitem>
<varlistentry><term>Class <ref refid="classnest_1_1correlation__detector" kindref="compound">nest::correlation_detector</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000001"/>The correlation detector could be made more efficient as follows (HEP 2008-07-01):<itemizedlist>
<listitem><para>incoming_ is vector of two deques</para>
</listitem><listitem><para>let <ref refid="classnest_1_1correlation__detector_1a7970ed77b27a84ecc28256eeb8e51316" kindref="member">handle()</ref> push_back() entries in incoming_ and do nothing else</para>
</listitem><listitem><para>keep index to last &quot;old spike&quot; in each incoming_; cannot be iterator since that may change</para>
</listitem><listitem><para><ref refid="classnest_1_1correlation__detector_1ae8f4a9cec7597a23d19d9f7bf0e1ab15" kindref="member">update()</ref> deletes all entries before now-tau_max, sorts the new entries, then registers new entries in histogram  </para>
</listitem></itemizedlist>
</para>
</listitem>
<varlistentry><term>Class <ref refid="structnest_1_1correlation__detector_1_1State__" kindref="compound">nest::correlation_detector::State_</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000002"/>Is there a replacement for std::list that allows fast insertion inside, fast deletion at the beginning, and maintains sorting?  </para>
</listitem>
<varlistentry><term>Class <ref refid="classnest_1_1correlomatrix__detector" kindref="compound">nest::correlomatrix_detector</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000003"/>The correlation detector could be made more efficient as follows (HEP 2008-07-01):<itemizedlist>
<listitem><para>incoming_ is vector of two deques</para>
</listitem><listitem><para>let <ref refid="classnest_1_1correlomatrix__detector_1a84891b0d4ab3820b9777fe9fb1b9dda9" kindref="member">handle()</ref> push_back() entries in incoming_ and do nothing else</para>
</listitem><listitem><para>keep index to last &quot;old spike&quot; in each incoming_; cannot be iterator since that may change</para>
</listitem><listitem><para><ref refid="classnest_1_1correlomatrix__detector_1a6a99fd6f081104a69d53d5d7401a9c06" kindref="member">update()</ref> deletes all entries before now-tau_max, sorts the new entries, then registers new entries in histogram  </para>
</listitem></itemizedlist>
</para>
</listitem>
<varlistentry><term>Class <ref refid="structnest_1_1correlomatrix__detector_1_1State__" kindref="compound">nest::correlomatrix_detector::State_</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000004"/>Is there a replacement for std::list that allows fast insertion inside, fast deletion at the beginning, and maintains sorting?  </para>
</listitem>
<varlistentry><term>Class <ref refid="structnest_1_1correlospinmatrix__detector_1_1State__" kindref="compound">nest::correlospinmatrix_detector::State_</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000005"/>Is there a replacement for std::list that allows fast insertion inside, fast deletion at the beginning, and maintains sorting?  </para>
</listitem>
<varlistentry><term>Member <ref refid="classnest_1_1Device_1ab78b2c8c5dd25d5328790c3d2d77bc02" kindref="member">nest::Device::get_t_max_</ref>  () const</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000010"/>Should be protected, but is temporarily public to solve inheritance problems in AnalogSamplingDevice.  </para>
</listitem>
<varlistentry><term>Member <ref refid="classnest_1_1Device_1a84e4ade576e165a46597963ae943b829" kindref="member">nest::Device::get_t_min_</ref>  () const</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000009"/>Should be protected, but is temporarily public to solve inheritance problems in AnalogSamplingDevice.  </para>
</listitem>
<varlistentry><term>Member <ref refid="classnest_1_1DynamicRecordablesMap_1a705c3c0b2fdc5177b85433159bf091e2" kindref="member">nest::DynamicRecordablesMap&lt; HostNode &gt;::get_list</ref>  () const</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000014"/>This fct should return the recordables_ entry, but since filling recordables_ leads to seg fault on exit, we just build the list every time, even though that beats the goal of being more efficient ...  </para>
</listitem>
<varlistentry><term>Member <ref refid="classnest_1_1mip__generator_1abd0c2c060dc2a93380c6625fc9d6dcc1" kindref="member">nest::mip_generator::event_hook</ref>  (<ref refid="classnest_1_1DSSpikeEvent" kindref="compound">DSSpikeEvent</ref> &amp;) override</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000006"/>Should use binomial distribution  </para>
</listitem>
<varlistentry><term>Member <ref refid="classnest_1_1ModelManager_1a328a98e2391f07ffdcd31a986982f826" kindref="member">nest::ModelManager::get_connection_model</ref>  (synindex syn_id, thread t=0)</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000011"/>: make the return type const, after the increment of num_connections and the min_ and max_delay setting in <ref refid="classnest_1_1ConnectorBase" kindref="compound">ConnectorBase</ref> was moved out to the <ref refid="classnest_1_1ConnectionManager" kindref="compound">ConnectionManager</ref>  </para>
</listitem>
<varlistentry><term>Class <ref refid="classnest_1_1ModelsModule" kindref="compound">nest::ModelsModule</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000007"/>Should this be a dynamic module?  </para>
</listitem>
<varlistentry><term>Member <ref refid="structnest_1_1multimeter_1_1Buffers___1a45250cf348b0e50f31eefdb889bfc486" kindref="member">nest::multimeter::Buffers_::Buffers_</ref>  ()</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000008"/>Ideally, one should be able to ask <ref refid="classnest_1_1ConnectionManager" kindref="compound">ConnectionManager</ref>.  </para>
</listitem>
<varlistentry><term>Member <ref refid="classnest_1_1RecordablesMap_1a8aa7c18011d00a166edc901cc6d343cc" kindref="member">nest::RecordablesMap&lt; HostNode &gt;::get_list</ref>  () const</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000012"/>This fct should return the recordables_ entry, but since filling recordables_ leads to seg fault on exit, we just build the list every time, even though that beats the goal of being more efficient ...  </para>
</listitem>
<varlistentry><term>Class <ref refid="classnest_1_1StimulationDevice" kindref="compound">nest::StimulationDevice</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000015"/>The timing of analog devices is correct only if they are transmitted using Network::send_local(), but we cannot enforce this currently. </para>
</listitem>
<varlistentry><term>Class <ref refid="classSLIArrayModule_1_1FiniteQ__dFunction" kindref="compound">SLIArrayModule::FiniteQ_dFunction</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000018"/>This class does not really belong into sliarray, but is placed here since it is a Mathematica-style Q function.  </para>
</listitem>
<varlistentry><term>Member <ref refid="group__SLIError_1gab1f76ff8c7308acedfa1017ffe2c7de4" kindref="member">SLIInterpreter::raisesignal</ref>  (int)</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000017"/>Document this function.</para>
</listitem>
</variablelist>
</para>
    </detaileddescription>
    <location file="todo"/>
  </compounddef>
</doxygen>
